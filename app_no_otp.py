
# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O0xbdhztglHuOw5TR4k0YAtYkOazi04g
"""

import streamlit as st
import pandas as pd
import psycopg2
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from pandas.api.types import is_datetime64_any_dtype
import warnings
from datetime import datetime, timedelta
import time
import os
from typing import Dict, Optional, Tuple, List

warnings.filterwarnings('ignore')

# Page configuration
st.set_page_config(
    page_title="Miva AI Database Analytics",
    page_icon="ðŸ“Š",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for styling with Miva brand theme
st.markdown("""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;500;600;700;800&display=swap');

    /* Global font family */
    html, body, [class*="css"] {
        font-family: 'Manrope', sans-serif;
    }

    .main-header {
        font-size: 2.5rem;
        font-weight: 700;
        color: #1e40af;
        text-align: center;
        margin-bottom: 2rem;
        padding: 1.5rem;
        background: linear-gradient(135deg, #f8fafc 0%, #ffffff 50%, #f1f5f9 100%);
        border-radius: 12px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.07);
        border: 1px solid #e2e8f0;
        font-family: 'Manrope', sans-serif;
    }

    /* Miva color scheme: Blue (#1e40af), Red (#dc2626), Ash (#64748b) */
    .metric-container {
        background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
        padding: 1.2rem;
        border-radius: 12px;
        color: white;
        box-shadow: 0 4px 12px rgba(30, 64, 175, 0.15);
        margin: 0.5rem 0;
        font-family: 'Manrope', sans-serif;
        border: 1px solid rgba(255,255,255,0.1);
    }

    .status-success {
        background: linear-gradient(135deg, #059669 0%, #10b981 100%);
        box-shadow: 0 4px 12px rgba(5, 150, 105, 0.15);
    }

    .status-error {
        background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%);
        box-shadow: 0 4px 12px rgba(220, 38, 38, 0.15);
    }

    .info-box {
        background: #f8fafc;
        padding: 1.2rem;
        border-radius: 10px;
        border-left: 4px solid #1e40af;
        margin: 1rem 0;
        font-family: 'Manrope', sans-serif;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    /* Button styling */
    .stButton > button {
        background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%);
        color: white;
        border: none;
        border-radius: 8px;
        font-family: 'Manrope', sans-serif;
        font-weight: 500;
        padding: 0.5rem 1rem;
        transition: all 0.3s ease;
    }

    .stButton > button:hover {
        background: linear-gradient(135deg, #1d4ed8 0%, #2563eb 100%);
        box-shadow: 0 4px 12px rgba(30, 64, 175, 0.3);
    }

    /* Primary button styling */
    .stButton > button[kind="primary"] {
        background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%);
    }

    .stButton > button[kind="primary"]:hover {
        background: linear-gradient(135deg, #b91c1c 0%, #dc2626 100%);
        box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
    }

    .stAlert > div {
        padding-top: 0.75rem;
        padding-bottom: 0.75rem;
    }
</style>
""", unsafe_allow_html=True)

class DatabaseConfig:
    """Database configuration management"""

    @staticmethod
    def get_config() -> Dict[str, str]:
        """Get database configuration from environment or Streamlit secrets"""
        try:
            # Try Streamlit secrets first (for Streamlit Cloud)
            if hasattr(st, 'secrets') and 'database' in st.secrets:
                return {
                    "host": st.secrets["database"]["host"],
                    "port": st.secrets["database"]["port"],
                    "user": st.secrets["database"]["user"],
                    "password": st.secrets["database"]["password"],
                    "database": st.secrets["database"]["database"]
                }
        except:
            pass

        # Fall back to environment variables
        return {
            "host": os.getenv("DB_HOST", "16.170.143.253"),
            "port": int(os.getenv("DB_PORT", "5432")),
            "user": os.getenv("DB_USER", "admin"),
            "password": os.getenv("DB_PASSWORD", "password123"),
            "database": os.getenv("DB_NAME", "miva_ai_db")
        }

class DatabaseManager:
    """Database connection and query management"""

    def __init__(self):
        self.config = DatabaseConfig.get_config()

    @st.cache_data(ttl=300)
    def test_connection(_self) -> Tuple[bool, str]:
        """Test database connection"""
        try:
            conn = psycopg2.connect(**_self.config)
            cursor = conn.cursor()
            cursor.execute("SELECT version();")
            version = cursor.fetchone()
            cursor.close()
            conn.close()
            return True, version[0] if version else "Unknown"
        except Exception as e:
            return False, str(e)

    @st.cache_data(ttl=300)
    def run_query(_self, query: str) -> List:
        """Execute a query and return results"""
        try:
            conn = psycopg2.connect(**_self.config)
            cursor = conn.cursor()
            cursor.execute(query)
            rows = cursor.fetchall()
            cursor.close()
            conn.close()
            return rows
        except Exception as e:
            st.error(f"Query error: {e}")
            return []

    @st.cache_data(ttl=300)
    def query_df(_self, query: str) -> pd.DataFrame:
        """Run a SQL query and return result as Pandas DataFrame"""
        try:
            conn = psycopg2.connect(**_self.config)
            df = pd.read_sql(query, conn)
            conn.close()
            return df
        except Exception as e:
            st.error(f"DataFrame query error: {e}")
            return pd.DataFrame()

class DataProcessor:
    """Data processing utilities"""

    @staticmethod
    def try_parse_datetimes(df: pd.DataFrame) -> pd.DataFrame:
        """Auto-parse likely datetime columns"""
        for col in df.columns:
            if df[col].dtype == "object" and any(k in col.lower() for k in ["time","date","at","created","updated"]):
                try:
                    df[col] = pd.to_datetime(df[col], errors="ignore", utc=True)
                except Exception:
                    pass
        return df

    @staticmethod
    def get_table_info(db_manager: DatabaseManager) -> pd.DataFrame:
        """Get table information with row counts"""
        try:
            # First try with the correct PostgreSQL system table structure
            query = """
            SELECT
                schemaname,
                relname as tablename,
                n_tup_ins as inserts,
                n_tup_upd as updates,
                n_tup_del as deletes,
                n_live_tup as live_rows,
                n_dead_tup as dead_rows
            FROM pg_stat_user_tables
            ORDER BY n_live_tup DESC;
            """
            result = db_manager.query_df(query)
            if not result.empty:
                return result
        except Exception as e:
            print(f"Primary query failed: {e}")

        try:
            # Fallback: Simple table list with manual row count
            query = """
            SELECT
                table_name as tablename,
                (SELECT COUNT(*) FROM information_schema.columns
                 WHERE table_name = t.table_name AND table_schema = 'public') as column_count
            FROM information_schema.tables t
            WHERE table_schema = 'public'
            ORDER BY table_name;
            """
            return db_manager.query_df(query)
        except Exception as e:
            print(f"Fallback query failed: {e}")

        # Final fallback: Just table names
        try:
            tables = db_manager.run_query("""
                SELECT table_name
                FROM information_schema.tables
                WHERE table_schema = 'public'
                ORDER BY table_name;
            """)
            return pd.DataFrame(tables, columns=['tablename'])
        except:
            return pd.DataFrame()

class CommentAnalyzer:
    """Comment analysis and display utilities"""

    @staticmethod
    def get_comments_by_rating(df: pd.DataFrame, rating: int, comment_col: str = 'comment') -> pd.DataFrame:
        """Get comments filtered by rating"""
        if comment_col not in df.columns:
            return pd.DataFrame()

        # Filter by rating and remove empty comments
        filtered = df[df['rating'] == rating].copy()
        filtered = filtered[filtered[comment_col].notna() & (filtered[comment_col].str.strip() != '')]

        return filtered.sort_values('created_at', ascending=False) if 'created_at' in filtered.columns else filtered

    @staticmethod
    def analyze_comment_sentiment(comments: pd.Series) -> dict:
        """Basic sentiment analysis of comments"""
        if comments.empty:
            return {"positive": 0, "negative": 0, "neutral": 0}

        # Simple keyword-based sentiment analysis
        positive_words = ['good', 'great', 'excellent', 'amazing', 'love', 'perfect', 'awesome', 'fantastic', 'helpful', 'satisfied']
        negative_words = ['bad', 'terrible', 'awful', 'hate', 'poor', 'disappointing', 'useless', 'frustrated', 'annoying', 'slow']

        sentiment_scores = []
        for comment in comments:
            if pd.isna(comment):
                continue

            comment_lower = str(comment).lower()
            positive_count = sum(1 for word in positive_words if word in comment_lower)
            negative_count = sum(1 for word in negative_words if word in comment_lower)

            if positive_count > negative_count:
                sentiment_scores.append('positive')
            elif negative_count > positive_count:
                sentiment_scores.append('negative')
            else:
                sentiment_scores.append('neutral')

        total = len(sentiment_scores)
        if total == 0:
            return {"positive": 0, "negative": 0, "neutral": 0}

        return {
            "positive": sentiment_scores.count('positive') / total * 100,
            "negative": sentiment_scores.count('negative') / total * 100,
            "neutral": sentiment_scores.count('neutral') / total * 100
        }

    @staticmethod
    def get_comment_statistics(df: pd.DataFrame, comment_col: str = 'comment') -> dict:
        """Get basic statistics about comments"""
        if comment_col not in df.columns:
            return {}

        comments = df[comment_col].dropna()
        if comments.empty:
            return {}

        # Calculate statistics
        lengths = comments.astype(str).str.len()
        word_counts = comments.astype(str).str.split().str.len()

        return {
            "total_comments": len(comments),
            "avg_length": lengths.mean(),
            "avg_words": word_counts.mean(),
            "longest_comment": lengths.max(),
            "shortest_comment": lengths.min()
        }

class Visualizer:
    """Visualization utilities using Plotly"""
    # Miva Brand Colors
    MIVA_BLUE = "#1e40af"
    MIVA_RED = "#dc2626"
    MIVA_ASH = "#64748b"

    @staticmethod
    def plot_missing_values(df: pd.DataFrame, title: str):
        """Create interactive missing values plot"""
        na_counts = df.isna().sum()
        na_counts = na_counts[na_counts > 0].sort_values(ascending=False)

        if na_counts.empty:
            st.success(f"âœ… No missing values in {title}")
            return

        fig = px.bar(
            x=na_counts.values,
            y=na_counts.index,
            orientation='h',
            title=f"{title}: Missing Values per Column",
            labels={'x': 'Missing Count', 'y': 'Columns'},
            color=na_counts.values,
            color_continuous_scale='Reds'
        )
        fig.update_layout(height=max(300, 40*len(na_counts)))
        st.plotly_chart(fig, use_container_width=True)

    @staticmethod
    def plot_interactive_rating_distribution(df: pd.DataFrame, col: str, title: str, comment_col: str = 'comment'):
        """Create interactive rating histogram with click functionality"""
        data = df[col].dropna()
        if data.empty:
            st.warning(f"No data in {col}")
            return

        # Create rating distribution
        rating_counts = data.value_counts().sort_index()

        # Check if comments exist
        has_comments = comment_col in df.columns and not df[comment_col].isna().all()

        if has_comments:
            st.markdown("#### ðŸ“Š Interactive Rating Distribution")
            st.info("ðŸ’¡ Click on a rating number below to view comments for that rating!")

            # Create clickable rating buttons
            st.markdown("##### Select a rating to view comments:")
            cols = st.columns(5)

            # Create session state for selected rating if not exists
            if 'selected_rating' not in st.session_state:
                st.session_state.selected_rating = None

            # Rating buttons
            for i, rating in enumerate([1, 2, 3, 4, 5]):
                with cols[i]:
                    count = rating_counts.get(rating, 0)
                    if st.button(f"â­ {rating}\n({count} reviews)",
                                  key=f"rating_{rating}",
                                  type="primary" if st.session_state.selected_rating == rating else "secondary"):
                        st.session_state.selected_rating = rating

        # Plot the distribution
        fig = px.histogram(
            x=data,
            nbins=5,
            title=f"{title}: Rating Distribution",
            labels={'x': col, 'y': 'Frequency'},
            color_discrete_sequence=[Visualizer.MIVA_BLUE]
        )

        # Highlight selected rating if any
        if has_comments and st.session_state.selected_rating is not None:
            fig.add_vline(
                x=st.session_state.selected_rating,
                line_dash="dash",
                line_color=Visualizer.MIVA_RED,
                line_width=3,
                annotation_text=f"Selected: {st.session_state.selected_rating}â­"
            )

        fig.update_layout(
            bargap=0.1,
            height=400,
            xaxis=dict(dtick=1)
        )
        st.plotly_chart(fig, use_container_width=True)

        # Show comments for selected rating
        if has_comments and st.session_state.selected_rating is not None:
            Visualizer._display_comments_for_rating(
                df, st.session_state.selected_rating, comment_col, title
            )

    @staticmethod
    def _display_comments_for_rating(df: pd.DataFrame, rating: int, comment_col: str, title: str):
        """Display comments for a specific rating"""
        comment_analyzer = CommentAnalyzer()

        # Get comments for the selected rating
        filtered_comments = comment_analyzer.get_comments_by_rating(df, rating, comment_col)

        if filtered_comments.empty:
            st.warning(f"No comments found for {rating}â­ rating.")
            return

        st.markdown(f"### ðŸ’¬ Comments for {rating}â­ Rating")

        # Comment statistics
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            st.metric("ðŸ“ Total Comments", len(filtered_comments))

        with col2:
            avg_length = filtered_comments[comment_col].astype(str).str.len().mean()
            st.metric("ðŸ“ Avg Length", f"{avg_length:.0f} chars")

        with col3:
            if 'created_at' in filtered_comments.columns:
                latest_date = filtered_comments['created_at'].max()
                st.metric("ðŸ“… Latest", latest_date.strftime("%m/%d") if pd.notna(latest_date) else "N/A")

        with col4:
            unique_users = filtered_comments['email'].nunique() if 'email' in filtered_comments.columns else 0
            st.metric("ðŸ‘¥ Unique Users", unique_users)

        # Sentiment analysis
        sentiment = comment_analyzer.analyze_comment_sentiment(filtered_comments[comment_col])
        if sentiment:
            st.markdown("#### ðŸŽ­ Sentiment Analysis")
            col1, col2, col3 = st.columns(3)

            with col1:
                st.metric("ðŸ˜Š Positive", f"{sentiment['positive']:.1f}%",
                          delta=f"{sentiment['positive'] - 33.3:.1f}%" if sentiment['positive'] != 33.3 else None)
            with col2:
                st.metric("ðŸ˜ Neutral", f"{sentiment['neutral']:.1f}%")
            with col3:
                st.metric("ðŸ˜ž Negative", f"{sentiment['negative']:.1f}%",
                          delta=f"{sentiment['negative'] - 33.3:.1f}%" if sentiment['negative'] != 33.3 else None,
                          delta_color="inverse")

        # Display comments in an expandable format
        st.markdown("#### ðŸ“‹ Individual Comments")

        # Search/filter functionality
        search_term = st.text_input("ðŸ” Search in comments:", placeholder="Type to filter comments...")

        # Filter comments based on search
        display_comments = filtered_comments
        if search_term:
            mask = display_comments[comment_col].astype(str).str.contains(search_term, case=False, na=False)
            display_comments = display_comments[mask]
            st.info(f"Found {len(display_comments)} comments matching '{search_term}'")

        # Pagination
        comments_per_page = 10
        total_comments = len(display_comments)
        total_pages = (total_comments + comments_per_page - 1) // comments_per_page

        if total_pages > 1:
            col1, col2, col3 = st.columns([2, 1, 2])
            with col2:
                page = st.selectbox("Page", range(1, total_pages + 1), key=f"page_rating_{rating}")

            start_idx = (page - 1) * comments_per_page
            end_idx = min(start_idx + comments_per_page, total_comments)
            display_comments = display_comments.iloc[start_idx:end_idx]

        # Display comments
        for idx, row in display_comments.iterrows():
            with st.expander(
                f"ðŸ’¬ Comment #{idx} - {row.get('email', 'Anonymous')} "
                f"({row.get('created_at', 'Unknown date').strftime('%Y-%m-%d %H:%M') if pd.notna(row.get('created_at')) else 'Unknown date'})",
                expanded=False
            ):
                # Comment content
                st.markdown("**Comment:**")
                st.write(row[comment_col])

                # Additional metadata in columns
                if any(col in row for col in ['user_agent', 'ip_address', 'email']):
                    st.markdown("**Details:**")
                    detail_cols = st.columns(3)

                    with detail_cols[0]:
                        if 'email' in row and pd.notna(row['email']):
                            st.text(f"ðŸ“§ {row['email']}")

                    with detail_cols[1]:
                        if 'ip_address' in row and pd.notna(row['ip_address']):
                            st.text(f"ðŸŒ {row['ip_address']}")

                    with detail_cols[2]:
                        if 'created_at' in row and pd.notna(row['created_at']):
                            st.text(f"ðŸ•’ {row['created_at'].strftime('%H:%M:%S')}")

        # Clear selection button
        if st.button("ðŸ”„ Clear Selection", key=f"clear_rating_{rating}"):
            st.session_state.selected_rating = None
            st.rerun()

    @staticmethod
    def plot_rating_distribution(df: pd.DataFrame, col: str, title: str):
        """Create interactive rating histogram"""
        data = df[col].dropna()
        if data.empty:
            st.warning(f"No data in {col}")
            return

        # Create histogram with statistics
        fig = make_subplots(
            rows=1, cols=2,
            subplot_titles=[f"{col} Distribution", "Rating Statistics"],
            specs=[[{"type": "xy"}, {"type": "indicator"}]]
        )

        # Histogram
        fig.add_trace(
            go.Histogram(x=data, nbinsx=5, name="Ratings", marker_color=Visualizer.MIVA_BLUE),
            row=1, col=1
        )

        # Statistics
        avg_rating = data.mean()
        fig.add_trace(
            go.Indicator(
                mode="gauge+number+delta",
                value=avg_rating,
                domain={'x': [0, 1], 'y': [0, 1]},
                title={'text': "Average Rating"},
                gauge={
                    'axis': {'range': [None, 5]},
                    'bar': {'color': Visualizer.MIVA_BLUE},
                    'steps': [
                        {'range': [0, 2], 'color': "#ffdddd"},
                        {'range': [2, 4], 'color': "#E0E0E0"},
                        {'range': [4, 5], 'color': "#add8e6"}
                    ],
                    'threshold': {
                        'line': {'color': Visualizer.MIVA_RED, 'width': 4},
                        'thickness': 0.75,
                        'value': 4.5
                    }
                }
            ),
            row=1, col=2
        )

        fig.update_layout(
            title=f"{title}: {col} Analysis",
            showlegend=False,
            height=400
        )
        st.plotly_chart(fig, use_container_width=True)

    @staticmethod
    def plot_top_categories(df: pd.DataFrame, col: str, title: str, top_n: int = 20):
        """Create interactive top categories plot"""
        if col not in df.columns:
            st.warning(f"Column '{col}' not found in {title}")
            return

        vc = df[col].astype("object").fillna("(Missing)").value_counts().head(top_n)
        if vc.empty:
            st.warning(f"No data in '{col}' for {title}")
            return

        # Truncate long labels for better display
        def truncate_label(label, max_length=50):
            if len(str(label)) > max_length:
                return str(label)[:max_length] + "..."
            return str(label)

        # Create truncated labels for display
        display_labels = [truncate_label(label) for label in vc.index]

        fig = px.bar(
            x=vc.values,
            y=display_labels,
            orientation='h',
            title=f"{title}: Top {top_n} {col} Values",
            labels={'x': 'Count', 'y': col},
            color=vc.values,
            color_continuous_scale='Blues',
            hover_data={'y': vc.index.tolist()}  # Show full text on hover
        )

        # Update layout for better text display
        fig.update_layout(
            height=max(500, 35*len(vc)),  # Increase height for better spacing
            yaxis=dict(
                categoryorder="total ascending",
                tickmode='linear',
                automargin=True,  # Auto-adjust margins for text
                tickfont=dict(size=9)  # Smaller font for y-axis labels
            ),
            margin=dict(l=200, r=50, t=50, b=50),  # Increase left margin for labels
            font=dict(size=10)  # Smaller font for better fit
        )

        st.plotly_chart(fig, use_container_width=True)

    @staticmethod
    def plot_time_trends(df: pd.DataFrame, title: str, freq: str = "D"):
        """Create interactive time trends plot"""
        time_cols = [c for c in df.columns if is_datetime64_any_dtype(df[c])]
        if not time_cols:
            st.warning(f"No datetime columns detected in {title}")
            return

        for col in time_cols:
            s = pd.to_datetime(df[col], errors="coerce", utc=True).dropna()
            if s.empty:
                continue

            s = s.dt.tz_convert(None)
            stamped = s.dt.floor(freq)
            counts = stamped.value_counts().sort_index()

            if counts.empty:
                continue

            # Create line plot with moving average
            fig = go.Figure()

            fig.add_trace(go.Scatter(
                x=counts.index,
                y=counts.values,
                mode='lines+markers',
                name='Daily Count',
                line=dict(color=Visualizer.MIVA_BLUE, width=2),
                marker=dict(size=4)
            ))

            # Add 7-day moving average if enough data
            if len(counts) >= 7:
                ma_7 = counts.rolling(window=7, center=True).mean()
                fig.add_trace(go.Scatter(
                    x=ma_7.index,
                    y=ma_7.values,
                    mode='lines',
                    name='7-day Moving Average',
                    line=dict(color=Visualizer.MIVA_RED, width=2, dash='dash')
                ))

            fig.update_layout(
                title=f"{title}: Trends by {col} ({freq})",
                xaxis_title="Time",
                yaxis_title="Count",
                hovermode='x unified',
                showlegend=True
            )

            st.plotly_chart(fig, use_container_width=True)

### MODIFICATION START ###
def login_page():
    """Displays the login page and handles authentication."""
    st.markdown('<h1 class="main-header">Miva AI Dashboard Login</h1>', unsafe_allow_html=True)

    # For demonstration, credentials are hardcoded.
    # In a real application, use st.secrets for security.
    # Example:
    # CORRECT_USERNAME = st.secrets["auth"]["username"]
    # CORRECT_PASSWORD = st.secrets["auth"]["password"]
    CORRECT_USERNAME = "miva_admin"
    CORRECT_PASSWORD = "password123"

    with st.form("login_form"):
        st.image("https://i.imgur.com/azwWWQN.jpeg", width=200)
        username = st.text_input("Username", key="login_username")
        password = st.text_input("Password", type="password", key="login_password")
        submitted = st.form_submit_button("Log In")

        if submitted:
            if username == CORRECT_USERNAME and password == CORRECT_PASSWORD:
                st.session_state["authenticated"] = True
                st.rerun()
            else:
                st.error("Incorrect username or password")

### MODIFICATION END ###


def create_dashboard():
    """Main dashboard application"""
    # Initialize components
    db_manager = DatabaseManager()
    processor = DataProcessor()
    viz = Visualizer()
    comment_analyzer = CommentAnalyzer()

    # Header
    st.markdown('<h1 class="main-header">Miva AI Database Analytics Dashboard</h1>', unsafe_allow_html=True)

    # Sidebar
    with st.sidebar:
        # Add Miva Logo at the top
        st.image("https://i.imgur.com/azwWWQN.jpeg", use_container_width=True)

        st.markdown("### ðŸ”§ Dashboard Controls")

        # Connection test
        st.markdown("#### Database Connection")
        if st.button("ðŸ”„ Test Connection", type="primary"):
            with st.spinner("Testing connection..."):
                success, info = db_manager.test_connection()
                if success:
                    st.success("âœ… Connected successfully!")
                    with st.expander("Connection Details"):
                        st.code(f"Host: {db_manager.config['host']}\nPort: {db_manager.config['port']}\nDatabase: {db_manager.config['database']}")
                        st.info(f"PostgreSQL: {info[:100]}...")
                else:
                    st.error(f"âŒ Connection failed")
                    st.error(f"Error: {info}")

        # Data management
        st.markdown("#### Data Management")
        col1, col2 = st.columns(2)
        with col1:
            if st.button("ðŸ”„ Refresh"):
                st.cache_data.clear()
                st.success("Cache cleared!")
                st.rerun()

        with col2:
            auto_refresh = st.checkbox("Auto-refresh", help="Refresh data every 5 minutes")

        # Analysis options
        st.markdown("#### Analysis Options")
        show_missing = st.checkbox("Missing Values", True)
        show_distributions = st.checkbox("Distributions", True)
        show_trends = st.checkbox("Time Trends", True)
        show_advanced = st.checkbox("Advanced Analytics", False)

        # Filters
        st.markdown("#### Filters")
        date_range = st.date_input(
            "Date Range",
            value=(datetime.now() - timedelta(days=30), datetime.now()),
            help="Filter data by date range"
        )
        
        ### MODIFICATION START ###
        # Logout Button
        st.markdown("---")
        if st.button("Log Out"):
            st.session_state["authenticated"] = False
            st.rerun()
        ### MODIFICATION END ###


    # Auto-refresh logic
    if auto_refresh:
        time.sleep(300)  # 5 minutes
        st.rerun()

    ### MODIFICATION START ###
    # Main tabs (OTP tab removed)
    tab1, tab2, tab3, tab4 = st.tabs([
        "ðŸ“‹ Overview",
        "ðŸ’¬ Chat Feedback",
        "ðŸ“Š Custom Analysis",
        "ðŸ” Advanced Analytics"
    ])
    ### MODIFICATION END ###


    with tab1:
        st.markdown("### Database Overview")

        # Get table information
        with st.spinner("Loading database information..."):
            try:
                table_info = processor.get_table_info(db_manager)

                if not table_info.empty:
                    # Metrics row
                    col1, col2, col3, col4 = st.columns(4)

                    total_tables = len(table_info)
                    total_rows = table_info.get('live_rows', [0]).sum() if 'live_rows' in table_info.columns else 0

                    with col1:
                        st.metric("ðŸ“Š Total Tables", total_tables)
                    with col2:
                        st.metric("ðŸ“ˆ Total Records", f"{total_rows:,}")
                    with col3:
                        last_update = datetime.now().strftime("%H:%M:%S")
                        st.metric("ðŸ•’ Last Updated", last_update)
                    with col4:
                        health_score = "ðŸŸ¢ Healthy" if total_rows > 0 else "ðŸŸ¡ Warning"
                        st.metric("ðŸ’š Status", health_score)

                    # Table details
                    st.markdown("### ðŸ“‹ Table Statistics")

                    if 'live_rows' in table_info.columns:
                        fig = px.bar(
                            table_info,
                            x='tablename',
                            y='live_rows',
                            title="Records per Table",
                            labels={'live_rows': 'Live Records', 'tablename': 'Table Name'},
                            color_discrete_sequence=[viz.MIVA_BLUE]
                        )
                        st.plotly_chart(fig, use_container_width=True)

                    # Display table info
                    st.dataframe(table_info, use_container_width=True)

            except Exception as e:
                st.error(f"Error loading overview: {e}")

    with tab2:
        st.markdown("### ðŸ’¬ Chat Feedback Analysis")

        with st.spinner("Loading chat feedback data..."):
            df_chat = db_manager.query_df("SELECT * FROM chat_feedback;")

            if not df_chat.empty:
                df_chat = processor.try_parse_datetimes(df_chat)

                # Apply date filter
                if len(date_range) == 2 and 'created_at' in df_chat.columns:
                    mask = (df_chat['created_at'].dt.date >= date_range[0]) & (df_chat['created_at'].dt.date <= date_range[1])
                    df_chat = df_chat.loc[mask]

                # Metrics dashboard
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric("ðŸ“Š Total Records", f"{len(df_chat):,}")
                with col2:
                    if 'rating' in df_chat.columns:
                        avg_rating = df_chat['rating'].mean()
                        st.metric("â­ Avg Rating", f"{avg_rating:.2f}")
                with col3:
                    if 'comment' in df_chat.columns:
                        comment_count = df_chat['comment'].notna().sum()
                        st.metric("ðŸ“ Comments", f"{comment_count:,}")
                with col4:
                    if 'email' in df_chat.columns:
                        unique_users = df_chat['email'].nunique()
                        st.metric("ðŸ‘¥ Unique Users", f"{unique_users:,}")

                # Visualizations in columns
                col1, col2 = st.columns(2)
                with col1:
                    if show_trends:
                        viz.plot_time_trends(df_chat, "Chat Feedback")
                    if show_missing:
                        viz.plot_missing_values(df_chat, "Chat Feedback")

                with col2:
                    if show_distributions and 'user_agent' in df_chat.columns:
                        viz.plot_top_categories(df_chat, 'user_agent', "Top User Agents", top_n=10)

                # Interactive rating analysis (full width)
                if show_distributions and 'rating' in df_chat.columns:
                    viz.plot_interactive_rating_distribution(df_chat, 'rating', "Chat Feedback", 'comment')

            else:
                st.warning("No chat feedback data found.")

    ### MODIFICATION START ###
    # This entire block for the OTP tab has been removed.
    ### MODIFICATION END ###

    with tab3: # Formerly tab4
        st.markdown("### ðŸ“Š Custom Analysis")
        st.info("ðŸ’¡ Write your own SQL query to explore the database.")

        # Default query for demonstration
        default_query = "SELECT \n    'chat_feedback' as source,\n    rating,\n    COUNT(*) as count\nFROM \n    chat_feedback\nGROUP BY \n    rating\nORDER BY \n    rating;"
        query = st.text_area("SQL Query", value=default_query, height=200)

        if st.button("ðŸš€ Run Query"):
            with st.spinner("Executing your query..."):
                df_custom = db_manager.query_df(query)

                if not df_custom.empty:
                    st.success(f"Query returned {len(df_custom)} rows.")
                    st.dataframe(df_custom, use_container_width=True)

                    # Simple visualization based on data
                    if len(df_custom.columns) >= 2:
                        st.markdown("#### ðŸ“ˆ Quick Visualization")
                        try:
                            # Guessing columns for plotting
                            x_col = df_custom.columns[0]
                            y_col = df_custom.columns[1]

                            # Ensure y-axis is numeric
                            if pd.api.types.is_numeric_dtype(df_custom[y_col]):
                                fig = px.bar(
                                    df_custom,
                                    x=x_col,
                                    y=y_col,
                                    title=f"Visualization of '{x_col}' vs '{y_col}'"
                                )
                                st.plotly_chart(fig, use_container_width=True)
                            else:
                                st.warning("Could not create a plot. The second column is not numeric.")

                        except Exception as e:
                            st.error(f"Could not automatically visualize: {e}")
                else:
                    st.warning("Query returned no results.")

    with tab4: # Formerly tab5
        st.markdown("### ðŸ” Advanced Analytics")

        if show_advanced:
            st.info("This section is for more complex, multi-table analytics.")

            # Example: Correlation analysis on chat feedback
            st.markdown("#### Correlation Heatmap for Chat Feedback")
            df_chat = db_manager.query_df("SELECT * FROM chat_feedback;")
            if not df_chat.empty:
                numeric_cols = df_chat.select_dtypes(include=np.number)
                if len(numeric_cols.columns) > 1:
                    corr = numeric_cols.corr()
                    fig = px.imshow(corr, text_auto=True, color_continuous_scale='RdBu_r')
                    st.plotly_chart(fig, use_container_width=True)
                else:
                    st.warning("Not enough numeric columns for a correlation heatmap.")

            # Add other advanced analytics here
            st.markdown("---")
            st.markdown("#### User Activity Analysis (Example)")
            query = """
            SELECT
                email,
                COUNT(*) as feedback_count,
                AVG(rating) as avg_rating,
                MAX(created_at) as last_feedback_date
            FROM chat_feedback
            WHERE email IS NOT NULL
            GROUP BY email
            ORDER BY feedback_count DESC
            LIMIT 20;
            """
            df_user_activity = db_manager.query_df(query)
            if not df_user_activity.empty:
                st.dataframe(df_user_activity, use_container_width=True)
            else:
                st.warning("No user activity data to display.")

        else:
            st.warning("Enable 'Advanced Analytics' in the sidebar to view this content.")

def main():
    """Main function to run the app with authentication."""
    if "authenticated" not in st.session_state:
        st.session_state["authenticated"] = False

    if st.session_state["authenticated"]:
        create_dashboard()
    else:
        login_page()

if __name__ == "__main__":
    main()
